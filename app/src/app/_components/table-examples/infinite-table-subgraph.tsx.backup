"use client";

import React, { useMemo, useState } from "react";
import { useInfiniteQuery } from "@tanstack/react-query";
import { Table } from "@/app/_components/generic-table";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { toast } from "sonner";

/**
 * ╔═══════════════════════════════════════════════════════════════════════════╗
 * ║              INFINITE TABLE WITH ETHERSCAN API QUERIES                    ║
 * ╠═══════════════════════════════════════════════════════════════════════════╣
 * ║                                                                           ║
 * ║  This component demonstrates using TanStack Query with Etherscan API      ║
 * ║  to fetch blockchain data. Etherscan provides comprehensive APIs for      ║
 * ║  accounts, transactions, tokens, contracts, and more.                     ║
 * ║                                                                           ║
 * ║  FEATURES:                                                                ║
 * ║  • REST API calls to Etherscan                                            ║
 * ║  • Page-based pagination (offset/limit)                                   ║
 * ║  • Token transfer history by address                                      ║
 * ║  • Support for ERC20, ERC721, ERC1155 tokens                              ║
 * ║                                                                           ║
 * ║  USE CASES:                                                               ║
 * ║  • Token transfer history for an address                                  ║
 * ║  • NFT transaction tracking                                               ║
 * ║  • Account transaction history                                            ║
 * ║  • Contract event logs                                                    ║
 * ║                                                                           ║
 * ║  API KEY:                                                                 ║
 * ║  Set ETHERSCAN_API_KEY in your .env file                                  ║
 * ║  Free tier: 5 calls/sec, 100k calls/day                                   ║
 * ║                                                                           ║
 * ╚═══════════════════════════════════════════════════════════════════════════╝
 */

// ============================================================================
// Constants
// ============================================================================

/**
 * Popular token contracts for demo purposes
 */
const TOKEN_CONTRACTS = {
  USDC: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
  USDT: "0xdAC17F958D2ee523a2206206994597C13D831ec7",
  DAI: "0x6B175474E89094C44Da98b954EedeAC495271d0F",
  WETH: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
  WBTC: "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599",
};

// ============================================================================
// Types
// ============================================================================

/**
 * Etherscan API response for ERC20 token transfers
 */
type EtherscanTransfer = {
  blockNumber: string;
  timeStamp: string;
  hash: string;
  nonce: string;
  blockHash: string;
  from: string;
  contractAddress: string;
  to: string;
  value: string;
  tokenName: string;
  tokenSymbol: string;
  tokenDecimal: string;
  transactionIndex: string;
  gas: string;
  gasPrice: string;
  gasUsed: string;
  cumulativeGasUsed: string;
  input: string;
  confirmations: string;
};

/**
 * Parsed transfer data for display
 */
type TransferData = {
  id: string; // Unique ID: hash-index
  blockNumber: number;
  timestamp: number;
  hash: string;
  from: string;
  to: string;
  value: string; // Human-readable amount
  tokenSymbol: string;
  tokenName: string;
};

type SortField = "blockNumber" | "value" | "timestamp";
type SortOrder = "asc" | "desc";

type HeaderContext = {
  sortField: SortField;
  sortOrder: SortOrder;
  setSortField: (field: SortField) => void;
  setSortOrder: (order: SortOrder) => void;
};

type EtherscanResponse = {
  status: string;
  message: string;
  result: EtherscanTransfer[];
};

type InfiniteQueryResponse = {
  items: TransferData[];
  nextCursor?: number; // Next page number
};

type FetchTransfersParams = {
  cursor?: number; // Page number
  limit: number;
  contractAddress: string;
  address?: string; // Optional: filter by specific address
};

// ============================================================================
// Etherscan API Fetcher Function
// ============================================================================

/**
 * Fetches ERC20 token transfers from Etherscan API
 *
 * ETHERSCAN API ENDPOINTS:
 * - Mainnet: https://api.etherscan.io/api
 * - Goerli: https://api-goerli.etherscan.io/api
 * - Sepolia: https://api-sepolia.etherscan.io/api
 *
 * PAGINATION:
 * Etherscan uses page and offset parameters:
 * - page: 1-indexed page number
 * - offset: items per page (max 10,000)
 *
 * RATE LIMITS (Free tier):
 * - 5 calls/second
 * - 100,000 calls/day
 *
 * @param params - Query parameters
 * @returns Promise resolving to parsed transfer data
 */
async function fetchTransfersFromEtherscan(
  params: FetchTransfersParams,
): Promise<InfiniteQueryResponse> {
  const { cursor = 1, limit, contractAddress, address } = params;

  // Get API key from environment
  const apiKey = process.env.ETHERSCAN_API_KEY;
  if (!apiKey) {
    throw new Error(
      "ETHERSCAN_API_KEY is not set in environment variables",
    );
  }

  // Build query parameters
  const queryParams = new URLSearchParams({
    module: "account",
    action: "tokentx",
    contractaddress: contractAddress,
    page: cursor.toString(),
    offset: limit.toString(),
    sort: "desc", // Most recent first
    apikey: apiKey,
  });

  // Optional: filter by specific address
  if (address?.trim()) {
    queryParams.append("address", address);
  }

  // Make API request
  const response = await fetch(
    `https://api.etherscan.io/api?${queryParams.toString()}`,
  );

  if (!response.ok) {
    throw new Error(`Etherscan API request failed: ${response.statusText}`);
  }

  const data = (await response.json()) as EtherscanResponse;

  // Check for API errors
  if (data.status === "0" && data.message !== "No transactions found") {
    throw new Error(`Etherscan API error: ${data.message}`);
  }

  // Handle "No transactions found"
  if (data.status === "0" || !data.result || data.result.length === 0) {
    return {
      items: [],
      nextCursor: undefined,
    };
  }

  // Parse and format transfers
  const items: TransferData[] = data.result.map((transfer, index) => {
    const decimals = parseInt(transfer.tokenDecimal);
    const value = (
      parseInt(transfer.value) /
      Math.pow(10, decimals)
    ).toFixed(decimals > 6 ? 6 : decimals);

    return {
      id: `${transfer.hash}-${index}`,
      blockNumber: parseInt(transfer.blockNumber),
      timestamp: parseInt(transfer.timeStamp),
      hash: transfer.hash,
      from: transfer.from,
      to: transfer.to,
      value,
      tokenSymbol: transfer.tokenSymbol,
      tokenName: transfer.tokenName,
    };
  });

  // Determine next cursor
  // If we got a full page, there might be more
  const nextCursor = items.length === limit ? cursor + 1 : undefined;

  return {
    items,
    nextCursor,
  };
}

// ============================================================================
// Render Functions
// ============================================================================

const renderRow = (transfer: TransferData, index: number) => {
  const formatAddress = (addr: string) =>
    `${addr.slice(0, 6)}...${addr.slice(-4)}`;

  return (
    <div key={`${transfer.id}-${index}`}>
      <div className="grid grid-cols-6 items-center gap-4 px-4 py-3 text-sm">
        <span className="font-mono text-xs">
          {transfer.blockNumber.toLocaleString()}
        </span>
        <span className="font-mono text-xs text-blue-400">
          {formatAddress(transfer.from)}
        </span>
        <span className="font-mono text-xs text-green-400">
          {formatAddress(transfer.to)}
        </span>
        <span className="font-semibold">
          {parseFloat(transfer.value).toLocaleString(undefined, {
            maximumFractionDigits: 4,
          })}{" "}
          {transfer.tokenSymbol}
        </span>
        <span className="text-xs text-gray-400">
          {new Date(transfer.timestamp * 1000).toLocaleString()}
        </span>
        <a
          href={`https://etherscan.io/tx/${transfer.hash}`}
          target="_blank"
          rel="noopener noreferrer"
          className="font-mono text-xs text-purple-400 hover:underline"
        >
          {formatAddress(transfer.hash)}
        </a>
      </div>
    </div>
  );
};

const renderLoadingRow = () => (
  <div>
    <div className="h-4 animate-pulse rounded bg-white/10" />
  </div>
);

const renderEmptyRow = () => (
  <div>
    <td className="px-4 py-8 text-center text-gray-400" colSpan={6}>
      No transfers found for this token.
    </td>
  </div>
);

// ============================================================================
// Header Component with Sorting Controls
// ============================================================================

const renderHeader = (context: HeaderContext | undefined) => {
  if (!context) {
    return (
      <div className="grid grid-cols-6 gap-4 px-4 py-3 text-sm font-medium text-gray-400">
        <span>Pool ID</span>
        <span>Pair</span>
        <span>Fee Tier</span>
        <span>TVL</span>
        <span>Volume</span>
        <span>Transactions</span>
      </div>
    );
  }

  const { sortField, sortOrder, setSortField, setSortOrder } = context;

  const handleSort = (field: SortField) => {
    if (sortField === field) {
      setSortOrder(sortOrder === "asc" ? "desc" : "asc");
    } else {
      setSortField(field);
      setSortOrder("desc"); // Default to desc for numeric fields
    }
  };

  const SortIndicator = ({ field }: { field: SortField }) => {
    if (sortField !== field) return null;
    return <span className="ml-1">{sortOrder === "asc" ? "↑" : "↓"}</span>;
  };

  return (
    <div className="grid grid-cols-6 gap-4 px-4 py-3 text-sm font-medium text-gray-400">
      <span>Pool ID</span>
      <span>Pair</span>
      <span>Fee Tier</span>
      <button
        onClick={() => handleSort("totalValueLockedUSD")}
        className="text-left transition-colors hover:text-white"
      >
        TVL
        <SortIndicator field="totalValueLockedUSD" />
      </button>
      <button
        onClick={() => handleSort("volumeUSD")}
        className="text-left transition-colors hover:text-white"
      >
        Volume
        <SortIndicator field="volumeUSD" />
      </button>
      <button
        onClick={() => handleSort("txCount")}
        className="text-left transition-colors hover:text-white"
      >
        Transactions
        <SortIndicator field="txCount" />
      </button>
    </div>
  );
};

// ============================================================================
// Main Component
// ============================================================================

/**
 * InfiniteTableSubgraph
 *
 * Demonstrates infinite scroll table using TanStack Query with The Graph
 * subgraph queries. Perfect for displaying blockchain data.
 *
 * SUBGRAPH PAGINATION:
 * The Graph uses cursor-based pagination with id_gt (greater than):
 * - Query 1: Get first 50 items
 * - Query 2: Get items where id > lastId from query 1
 * - This ensures no duplicates and works with real-time data
 *
 * PERFORMANCE TIPS:
 * - Use 'first' parameter (not skip/offset) for pagination
 * - Index frequently queried fields in your subgraph schema
 * - Keep queries focused (don't fetch unnecessary fields)
 * - Use fragments for reusable field sets
 */
export default function InfiniteTableSubgraph() {
  // ==========================================================================
  // STATE
  // ==========================================================================

  const [search, setSearch] = useState("");
  const [sortField, setSortField] = useState<SortField>("totalValueLockedUSD");
  const [sortOrder, setSortOrder] = useState<SortOrder>("desc");

  // ==========================================================================
  // INFINITE QUERY WITH SUBGRAPH
  // ==========================================================================

  const {
    data: tableData,
    isLoading,
    hasNextPage,
    isFetchingNextPage,
    fetchNextPage,
    isError,
    error,
  } = useInfiniteQuery<InfiniteQueryResponse, Error>({
    queryKey: [
      "pools",
      "subgraph",
      {
        search: search || undefined,
        sortBy: sortField,
        sortOrder,
      },
    ],
    queryFn: ({ pageParam }) =>
      fetchPoolsFromSubgraph({
        cursor: pageParam as string | undefined,
        limit: 50,
        search: search || undefined,
        sortBy: sortField,
        sortOrder,
      }),
    initialPageParam: undefined,
    getNextPageParam: (lastPage) => lastPage.nextCursor,
    staleTime: 30 * 1000, // 30 seconds (subgraph data updates frequently)
    retry: 2, // Retry failed queries (network issues)
  });

  // ==========================================================================
  // ERROR HANDLING
  // ==========================================================================

  React.useEffect(() => {
    if (isError && error) {
      toast.error("Failed to fetch subgraph data", {
        description:
          error.message || "An error occurred while querying subgraph",
      });
    }
  }, [isError, error]);

  // ==========================================================================
  // DATA TRANSFORMATION
  // ==========================================================================

  const allItems = useMemo(
    () => tableData?.pages.flatMap((page) => page.items) ?? [],
    [tableData],
  );

  // ==========================================================================
  // RENDER
  // ==========================================================================

  return (
    <div className="space-y-6">
      {/* Controls */}
      <div className="rounded-lg bg-white/10 p-6">
        <div className="mb-4">
          <div className="space-y-2">
            <Label htmlFor="search">Search Pools</Label>
            <Input
              id="search"
              type="text"
              value={search}
              onChange={(e) => setSearch(e.target.value)}
              placeholder="Search by token symbol or name..."
            />
          </div>
        </div>
        <div className="space-y-2">
          <p className="text-sm text-gray-400">
            Click on column headers to sort
          </p>
          <p className="text-xs text-gray-500">
            Data from The Graph Protocol • Updates every ~15 seconds
          </p>
        </div>
      </div>

      {/* Table */}
      <Table<PoolData, HeaderContext>
        data={allItems}
        isError={isError}
        triggerOffset={20}
        isLoading={isLoading}
        pageLimit={50}
        renderRow={renderRow}
        hasNextPage={hasNextPage}
        renderHeader={renderHeader}
        renderHeaderContext={{
          sortField,
          sortOrder,
          setSortField,
          setSortOrder,
        }}
        fetchNextPage={fetchNextPage}
        renderEmptyRow={renderEmptyRow}
        renderLoadingRow={renderLoadingRow}
        isFetchingNextPage={isFetchingNextPage}
        className="max-h-[800px]"
      />
    </div>
  );
}
